#!/usr/bin/env python3

from __future__ import annotations

import argparse
import hashlib
import os
from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True)
class ReleaseArtifact:
    platform: str
    arch: str
    tarball_name: str
    sha256: str


def _parse_tarball_name(filename: str) -> tuple[str, str, str] | None:
    # Expected: w-<tag>-<platform>-<arch>.tar.gz
    if not filename.endswith(".tar.gz"):
        return None
    stem = filename[: -len(".tar.gz")]
    if not stem.startswith("w-"):
        return None
    parts = stem[len("w-") :].split("-")
    if len(parts) < 3:
        return None
    platform = parts[-2]
    arch = parts[-1]
    tag = "-".join(parts[:-2])
    return tag, platform, arch


def _sha256_file(path: Path) -> str:
    return hashlib.sha256(path.read_bytes()).hexdigest()


def _sha256_from_sidecar(path: Path) -> str | None:
    sidecar = Path(str(path) + ".sha256")
    if not sidecar.exists():
        return None
    return sidecar.read_text(encoding="utf-8").strip().split()[0]


def _collect_release_artifacts(dist_dir: Path, tag: str) -> list[ReleaseArtifact]:
    artifacts: list[ReleaseArtifact] = []
    for tarball in dist_dir.glob("*.tar.gz"):
        parsed = _parse_tarball_name(tarball.name)
        if parsed is None:
            continue
        parsed_tag, platform, arch = parsed
        if parsed_tag != tag:
            continue

        sha = _sha256_from_sidecar(tarball) or _sha256_file(tarball)
        artifacts.append(
            ReleaseArtifact(
                platform=platform,
                arch=arch.upper(),
                tarball_name=tarball.name,
                sha256=sha,
            )
        )
    return artifacts


def _render_formula(*, repo: str, tag: str, artifacts: dict[tuple[str, str], ReleaseArtifact]) -> str:
    version = tag[1:] if tag.startswith("v") else tag

    def url_for(key: tuple[str, str]) -> str:
        return f"https://github.com/{repo}/releases/download/{tag}/{artifacts[key].tarball_name}"

    def sha_for(key: tuple[str, str]) -> str:
        return artifacts[key].sha256

    # Homebrew is relevant for macOS + Linux. This formula ships prebuilt binaries for:
    # - macOS arm64 + x86_64
    # - Linux x86_64
    mac_arm = ("macos", "ARM64")
    mac_x64 = ("macos", "X64")
    linux_arm = ("linux", "ARM64")
    linux_x64 = ("linux", "X64")

    missing = [k for k in (mac_arm, mac_x64, linux_x64) if k not in artifacts]
    if missing:
        present = ", ".join(sorted({f"{p}-{a}" for (p, a) in artifacts.keys()}))
        want = ", ".join([f"{p}-{a}" for (p, a) in missing])
        raise SystemExit(
            f"Missing required release artifacts for formula update: {want}. Present: {present or '(none)'}"
        )

    linux_block = ""
    if linux_arm in artifacts:
        linux_block = f'''  on_linux do
    if Hardware::CPU.arm?
      url "{url_for(linux_arm)}"
      sha256 "{sha_for(linux_arm)}"
    else
      url "{url_for(linux_x64)}"
      sha256 "{sha_for(linux_x64)}"
    end
  end
'''
    else:
        linux_block = f'''  on_linux do
    if Hardware::CPU.arm?
      odie "No prebuilt Linux ARM64 artifacts are published for this release."
    end

    url "{url_for(linux_x64)}"
    sha256 "{sha_for(linux_x64)}"
  end
'''

    return f'''# This file is @generated by scripts/update_homebrew_formula.py.
class W < Formula
  desc "Experimental multi-repo wrapper for Worktrunk"
  homepage "https://github.com/{repo}"
  version "{version}"

  on_macos do
    if Hardware::CPU.arm?
      url "{url_for(mac_arm)}"
      sha256 "{sha_for(mac_arm)}"
    else
      url "{url_for(mac_x64)}"
      sha256 "{sha_for(mac_x64)}"
    end
  end
{linux_block}

  head do
    url "https://github.com/{repo}.git", branch: "main"
    depends_on "rust" => :build
  end

  def install
    if build.head?
      system "cargo", "install", "--locked", "--path", "crates/w", "--bin", "w", "--root", prefix
      system "cargo", "install", "--locked", "--path", "vendor/worktrunk", "--bin", "wt", "--root", prefix
      return
    end

    pkg_dir = Dir["w-*"].first
    if pkg_dir.nil?
      bin.install "w"
      bin.install "wt"
      return
    end

    bin.install "#{pkg_dir}/w"
    bin.install "#{pkg_dir}/wt"
  end

  test do
    assert_match "zsh", shell_output("#{bin}/w shell init zsh")
  end
end
'''


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Update Formula/w.rb to point at a tagged GitHub release tarball + sha256 checksums."
    )
    parser.add_argument("--repo", default=os.environ.get("GITHUB_REPOSITORY", "prateek/w"))
    parser.add_argument("--tag", required=True, help="Git tag (e.g., v0.1.0)")
    parser.add_argument("--dist-dir", default="dist")
    parser.add_argument("--formula-path", default="Formula/w.rb")
    args = parser.parse_args()

    dist_dir = Path(args.dist_dir)
    formula_path = Path(args.formula_path)

    artifacts = _collect_release_artifacts(dist_dir, args.tag)
    by_key = {(a.platform, a.arch): a for a in artifacts}

    rendered = _render_formula(repo=args.repo, tag=args.tag, artifacts=by_key)
    formula_path.parent.mkdir(parents=True, exist_ok=True)
    formula_path.write_text(rendered, encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
