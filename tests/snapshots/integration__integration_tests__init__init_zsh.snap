---
source: tests/integration_tests/init.rs
info:
  program: wt
  args:
    - config
    - shell
    - init
    - zsh
  env:
    CLICOLOR_FORCE: "1"
    COLUMNS: "150"
    GIT_AUTHOR_DATE: "2025-01-01T00:00:00Z"
    GIT_COMMITTER_DATE: "2025-01-01T00:00:00Z"
    GIT_CONFIG_GLOBAL: "[TEST_GIT_CONFIG]"
    GIT_CONFIG_SYSTEM: /dev/null
    GIT_EDITOR: ""
    LANG: C
    LC_ALL: C
    SOURCE_DATE_EPOCH: "1761609600"
    WORKTRUNK_CONFIG_PATH: "[TEST_CONFIG]"
---
success: true
exit_code: 0
----- stdout -----
# worktrunk shell integration for zsh

# Only initialize if wt is available (in PATH or via WORKTRUNK_BIN)
if command -v wt >/dev/null 2>&1 || [[ -n "${WORKTRUNK_BIN:-}" ]]; then
    # Use WORKTRUNK_BIN if set, otherwise resolve binary path
    # Must resolve BEFORE defining shell function, so lazy completion can call binary directly
    # This allows testing development builds: export WORKTRUNK_BIN=./target/debug/wt
    _WORKTRUNK_CMD="${WORKTRUNK_BIN:-$(command -v wt)}"

# Shared directive parser for POSIX shells (bash, zsh, oil).
# Streams worktrunk's NUL-delimited output in real-time via FIFO while keeping
# stderr attached to the TTY for child processes (colors, progress bars).
#
# Note: Named without leading underscore to avoid being filtered by shell
# snapshot systems (e.g., Claude Code) that exclude private functions.
# Note: Uses ${_WORKTRUNK_CMD:-wt} fallback because shell snapshot
# systems may capture functions but not environment variables.
wt_exec() {
    # ┌─────────────────────────────────────────────────────────────────────────┐
    # │ BASH JOB CONTROL: Why we need TWO suppression mechanisms                │
    # │                                                                         │
    # │ Bash has two separate job notification mechanisms that are controlled   │
    # │ by DIFFERENT flags:                                                     │
    # │                                                                         │
    # │ 1. START notification "[1] 12345" (when `&` runs):                      │
    # │    - Controlled by `interactive` flag, NOT `monitor` (-m)               │
    # │    - Printed by describe_pid() via DESCRIBE_PID macro in jobs.c         │
    # │    - Cannot be disabled by any shell option in an interactive shell     │
    # │    - Must be suppressed via stderr redirection: { cmd & } 2>/dev/null   │
    # │                                                                         │
    # │ 2. DONE notification "[1]+ Done ..." (at next prompt):                  │
    # │    - Controlled by `monitor` (-m) option                                │
    # │    - Only printed for jobs started while monitor mode was ON            │
    # │    - Suppressed by `set +m` BEFORE backgrounding the job                │
    # │                                                                         │
    # │ References:                                                             │
    # │ - https://www.gnu.org/s/bash/manual/html_node/Job-Control-Basics.html   │
    # │ - https://superuser.com/questions/489722 (job notifications vs monitor) │
    # │ - https://stackoverflow.com/questions/20707316 (suppress background)    │
    # └─────────────────────────────────────────────────────────────────────────┘

    # Suppress DONE notifications by disabling monitor mode.
    # zsh: LOCAL_OPTIONS makes the change function-scoped (automatic restore)
    # bash: must manually save/restore since set +m affects the global shell
    # Note: We only touch -m, not -b (notify), to preserve user's notify preference.
    local _wt_saved_monitor=""
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        setopt LOCAL_OPTIONS NO_MONITOR
    elif [[ -n "${BASH_VERSION:-}" && $- == *m* ]]; then
        _wt_saved_monitor=1
        set +m
    fi

    local exec_cmd="" chunk="" exit_code=0 tmp_dir="" fifo_path="" runner_pid=""

    # Cleanup handler for signals and normal exit
    _wt_cleanup() {
        # Kill background process if still running
        if [[ -n "$runner_pid" ]] && kill -0 "$runner_pid" 2>/dev/null; then
            kill "$runner_pid" 2>/dev/null || true
        fi
        # Remove temp files
        /bin/rm -f "$fifo_path" 2>/dev/null || true
        /bin/rmdir "$tmp_dir" 2>/dev/null || true
        # Restore bash job control if we disabled it
        [[ -n "$_wt_saved_monitor" ]] && set -m
    }

    # On SIGINT: cleanup and exit immediately with 130
    trap '_wt_cleanup; return 130' INT

    # Create temp directory with FIFO for streaming output
    tmp_dir=$(mktemp -d "${TMPDIR:-/tmp}/wt.XXXXXX") || {
        echo "Failed to create temp directory for worktrunk shim" >&2
        [[ -n "$_wt_saved_monitor" ]] && set -m
        return 1
    }
    fifo_path="$tmp_dir/stdout.fifo"

    if ! mkfifo "$fifo_path"; then
        echo "Failed to create FIFO for worktrunk shim" >&2
        /bin/rm -rf "$tmp_dir"
        [[ -n "$_wt_saved_monitor" ]] && set -m
        return 1
    fi

    # Run worktrunk in background, piping stdout to FIFO.
    # Backgrounding is required: the FIFO blocks until both ends connect, so we
    # must background the writer (wt) while the foreground reads from it.
    #
    # For bash: Suppress the START notification "[1] 12345" via fd redirection.
    # The job-start message is printed by bash's describe_pid() to stderr when
    # `&` executes. By wrapping in { } with 2>/dev/null, we catch that message
    # while preserving the command's own stderr via fd 9.
    #
    # This pattern is stable across bash 3.x-5.x: describe_pid() has printed to
    # stderr since early bash versions, and redirections on grouped commands
    # affecting the shell's own writes is standard POSIX behavior.
    if [[ -n "${BASH_VERSION:-}" ]]; then
        exec 9>&2  # Save real stderr to fd 9 for the command's errors
        { command "${_WORKTRUNK_CMD:-wt}" "$@" >"$fifo_path" 2>&9 & } 2>/dev/null
        runner_pid=$!
        exec 9>&-  # Close fd 9
    else
        command "${_WORKTRUNK_CMD:-wt}" "$@" >"$fifo_path" &
        runner_pid=$!
    fi

    # Parse directives as they stream in
    while IFS= read -r -d '' chunk || [[ -n "$chunk" ]]; do
        if [[ "$chunk" == __WORKTRUNK_CD__* ]]; then
            # Directory change directive
            local path="${chunk#__WORKTRUNK_CD__}"
            \cd "$path"
        elif [[ "$chunk" == __WORKTRUNK_EXEC__* ]]; then
            # Command execution directive (deferred until after worktrunk exits)
            exec_cmd="${chunk#__WORKTRUNK_EXEC__}"
        else
            # Regular output - print to stdout
            [[ -n "$chunk" ]] && printf '%s\n' "$chunk"
        fi
    done <"$fifo_path"

    # Wait for worktrunk to complete and capture its exit code.
    # Note: `wait $pid` works correctly even with monitor mode disabled (set +m).
    # Unlike `disown` which removes jobs from bash's tracking entirely, `set +m`
    # only disables job control features (fg/bg, DONE notifications) while still
    # allowing exit status retrieval via wait.
    wait "$runner_pid" >/dev/null 2>&1 || exit_code=$?

    # Cleanup
    trap - INT
    _wt_cleanup

    # Execute deferred command if specified (its exit code takes precedence)
    if [[ -n "$exec_cmd" ]]; then
        eval "$exec_cmd"
        exit_code=$?
    fi

    return "${exit_code:-0}"
}

    # Override wt command to add --internal flag
    wt() {
        # Initialize _WORKTRUNK_CMD if not set (e.g., after shell snapshot restore)
        if [[ -z "$_WORKTRUNK_CMD" ]]; then
            _WORKTRUNK_CMD="${WORKTRUNK_BIN:-$(command -v wt)}"
        fi

        local use_source=false
        local -a args
        local saved_cmd="$_WORKTRUNK_CMD"

        # Check for --source flag and strip it
        for arg in "$@"; do
            if [[ "$arg" == "--source" ]]; then
                use_source=true
            else
                args+=("$arg")
            fi
        done

        # If --source was specified, build and use local debug binary
        if [[ "$use_source" == true ]]; then
            if ! cargo build --quiet; then
                _WORKTRUNK_CMD="$saved_cmd"
                return 1
            fi
            _WORKTRUNK_CMD="./target/debug/wt"
        fi

        # Force colors if stderr is a TTY (directive mode outputs to stderr)
        # Respects NO_COLOR and explicit CLICOLOR_FORCE
        if [[ -z "${NO_COLOR:-}" && -z "${CLICOLOR_FORCE:-}" ]]; then
            if [[ -t 2 ]]; then export CLICOLOR_FORCE=1; fi
        fi

        # Always use --internal mode for directive support
        wt_exec --internal "${args[@]}"

        # Restore original command
        local result=$?
        _WORKTRUNK_CMD="$saved_cmd"
        return $result
    }

    # Lazy completions - generate on first TAB, then delegate to clap's completer
    # NOTE: This must come AFTER compinit in your .zshrc
    _wt_lazy_complete() {
        # Generate completions function once (check if clap's function exists)
        if ! (( $+functions[_clap_dynamic_completer_wt] )); then
            eval "$(COMPLETE=zsh "$_WORKTRUNK_CMD" 2>/dev/null)" || return
        fi
        _clap_dynamic_completer_wt "$@"
    }

    # Register completion (requires compinit to have run first)
    if (( $+functions[compdef] )); then
        compdef _wt_lazy_complete wt
    else
        echo "wt: completions disabled (compinit not loaded yet)" >&2
        echo "wt: move 'eval \"\$(wt config shell init zsh)\"' after compinit in your .zshrc" >&2
    fi
fi

----- stderr -----
