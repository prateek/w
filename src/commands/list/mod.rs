//! List command for displaying worktrees and branches.
//!
//! # Performance
//!
//! `wt list` runs multiple git commands per worktree in parallel using Rayon. Performance
//! depends heavily on git's internal caches, not worktrunk-specific caching.
//!
//! ## Git Commands Per Worktree
//!
//! For each worktree, we execute:
//! - `git status --porcelain` - Working tree state (uses index cache)
//! - `git rev-list --count <base>..<head>` - Ahead/behind counts (uses commit graph)
//! - `git diff --numstat HEAD` - Working tree line diffs (uses index + tree objects)
//! - `git diff --numstat <base>...<head>` - Branch line diffs (uses tree objects)
//! - `git rev-parse <ref>` - Ref resolution (uses ref cache)
//!
//! Plus one global command:
//! - `git worktree list --porcelain` - List all worktrees (uses ref cache)
//!
//! ## Git's Internal Caches
//!
//! Git caches significantly affect performance. These caches are maintained by git itself:
//!
//! 1. **Index (`.git/index`)** - Cached file metadata (mtime, size, mode)
//!    - Speeds up `git status` by avoiding full file content comparisons
//!    - Invalidated when files change or staging area updates
//!    - Cold: ~100ms per worktree, Warm: ~10ms per worktree (typical repo)
//!
//! 2. **Commit graph (`.git/objects/info/commit-graph`)** - Precomputed commit metadata
//!    - Speeds up `git rev-list --count` by avoiding commit object parsing
//!    - Generated by `git commit-graph write` (some repos auto-generate)
//!    - Without: O(commits) parsing, With: O(1) metadata lookup
//!    - Cold: ~50ms for 1000 commits, Warm: ~5ms (with commit graph)
//!
//! 3. **Ref cache (`.git/refs/` and `.git/packed-refs`)** - Cached ref resolutions
//!    - Speeds up `git rev-parse` and branch lookups
//!    - Packed refs improve performance in repos with many branches
//!    - Cold: ~10ms, Warm: <1ms
//!
//! 4. **Filesystem cache (OS-level)** - Recently accessed files stay in memory
//!    - Speeds up all git operations after first access
//!    - Cleared when system is under memory pressure
//!    - Most impactful for large repos with many pack files
//!
//! 5. **Pack files (`.git/objects/pack/`)** - Compressed object storage
//!    - Faster than loose objects for bulk access
//!    - `git gc` consolidates loose objects into packs
//!    - More efficient for tree/blob access in diffs
//!
//! ## Worktrunk's Only Cache: Default Branch
//!
//! Worktrunk caches only the default branch name (main/master) using `git remote set-head`.
//! This is a git-native cache stored in `.git/refs/remotes/origin/HEAD`. All other data is
//! fetched fresh on each `wt list` invocation.
//!
//! Refresh with: `wt config refresh-cache`
//!
//! ## Performance Characteristics
//!
//! Scaling (from benches/list.rs):
//! - Linear with worktree count due to parallelization (Rayon thread pool)
//! - Dominated by git command overhead, not Rust code
//! - Cold caches: ~150-300ms per worktree (typical repo, 500 commits, 100 files)
//! - Warm caches: ~20-50ms per worktree
//! - Real-world: rust-lang/rust repo with 8 worktrees: ~400ms (warm caches)
//!
//! Bottlenecks:
//! 1. `git status --porcelain` - Slowest when index is cold or many files changed
//! 2. `git rev-list --count` - Slow without commit graph in repos with deep history
//! 3. `git diff --numstat` - Slow for large diffs or when pack files aren't cached
//!
//! Optimization tips:
//! - Run `git commit-graph write --reachable --changed-paths` to speed up commit counting
//! - Run `git gc` periodically to consolidate objects into pack files
//! - Minimize uncommitted changes across worktrees (each dirty worktree adds diff overhead)

mod ci_status;
pub(crate) mod collect;
mod collect_progressive_impl;
mod columns;
mod layout;
pub mod model;
mod progressive;
mod render;

#[cfg(test)]
mod spacing_test;

use layout::{LayoutConfig, calculate_responsive_layout};
use model::{ListData, ListItem};
use progressive::RenderMode;
use worktrunk::git::{GitError, Repository};

pub fn handle_list(
    format: crate::OutputFormat,
    show_branches: bool,
    show_full: bool,
    progressive: bool,
    no_progressive: bool,
    directive_mode: bool,
) -> Result<(), GitError> {
    let repo = Repository::current();

    let fetch_ci = show_full; // Only fetch CI with --full (expensive)
    let check_conflicts = show_full; // Only check conflicts with --full (expensive)

    // Detect whether to show progress bars (only for table format)
    let show_progress = match format {
        crate::OutputFormat::Table => {
            RenderMode::detect(progressive, no_progressive, directive_mode)
                == RenderMode::Progressive
        }
        crate::OutputFormat::Json => false, // JSON never shows progress
    };

    let list_data = collect::collect(
        &repo,
        show_branches,
        show_full,
        fetch_ci,
        check_conflicts,
        show_progress,
    )?;

    let Some(ListData {
        items,
        current_worktree_path,
    }) = list_data
    else {
        return Ok(());
    };

    match format {
        crate::OutputFormat::Json => {
            // Display fields are already computed in collect()
            let json = serde_json::to_string_pretty(&items).map_err(|e| {
                GitError::CommandFailed(format!("Failed to serialize to JSON: {}", e))
            })?;
            crate::output::raw(json)?;
        }
        crate::OutputFormat::Table => {
            let layout = calculate_responsive_layout(&items, show_full, fetch_ci);

            // Progressive mode renders table during collection; buffered mode renders here
            if !show_progress {
                crate::output::raw_terminal(layout.format_header_line())?;
                for item in &items {
                    crate::output::raw_terminal(
                        layout.format_list_item_line(item, current_worktree_path.as_ref()),
                    )?;
                }
            }

            // Summary:
            // - progressive + TTY: already shown via footer.finish_with_message
            // - progressive + non-TTY: already shown via multi.suspend() in collect.rs
            // - buffered: render here
            if !show_progress {
                layout.render_summary(&items, show_branches)?;
            }
        }
    }

    Ok(())
}

#[derive(Default)]
pub(super) struct SummaryMetrics {
    worktrees: usize,
    branches: usize,
    dirty_worktrees: usize,
    ahead_items: usize,
}

impl SummaryMetrics {
    pub(super) fn from_items(items: &[ListItem]) -> Self {
        let mut metrics = Self::default();
        for item in items {
            metrics.update(item);
        }
        metrics
    }

    fn update(&mut self, item: &ListItem) {
        if let Some(info) = item.worktree_data() {
            self.worktrees += 1;
            if info
                .working_tree_diff
                .as_ref()
                .map(|d| !d.is_empty())
                .unwrap_or(false)
            {
                self.dirty_worktrees += 1;
            }
        } else {
            self.branches += 1;
        }

        let counts = item.counts();
        if counts.ahead > 0 {
            self.ahead_items += 1;
        }
    }

    pub(super) fn summary_parts(
        &self,
        include_branches: bool,
        hidden_columns: usize,
    ) -> Vec<String> {
        let mut parts = Vec::new();

        if include_branches {
            parts.push(format!("{} worktrees", self.worktrees));
            if self.branches > 0 {
                parts.push(format!("{} branches", self.branches));
            }
        } else {
            let plural = if self.worktrees == 1 { "" } else { "s" };
            parts.push(format!("{} worktree{}", self.worktrees, plural));
        }

        if self.dirty_worktrees > 0 {
            parts.push(format!("{} with changes", self.dirty_worktrees));
        }

        if self.ahead_items > 0 {
            parts.push(format!("{} ahead", self.ahead_items));
        }

        if hidden_columns > 0 {
            let plural = if hidden_columns == 1 {
                "column"
            } else {
                "columns"
            };
            parts.push(format!("{} {} hidden", hidden_columns, plural));
        }

        parts
    }
}

/// Format a summary message for the given items (used by both collect.rs and mod.rs)
pub(crate) fn format_summary_message(
    items: &[ListItem],
    show_branches: bool,
    hidden_nonempty_count: usize,
) -> String {
    use anstyle::Style;
    use worktrunk::styling::INFO_EMOJI;

    let metrics = SummaryMetrics::from_items(items);
    let dim = Style::new().dimmed();
    let summary = metrics
        .summary_parts(show_branches, hidden_nonempty_count)
        .join(", ");
    format!("{INFO_EMOJI} {dim}Showing {summary}{dim:#}")
}

impl LayoutConfig {
    fn render_summary(&self, items: &[ListItem], include_branches: bool) -> Result<(), GitError> {
        use worktrunk::styling::{HINT, INFO_EMOJI};

        if items.is_empty() {
            crate::output::raw_terminal("")?;
            crate::output::hint(format!("{HINT}No worktrees found{HINT:#}"))?;
            crate::output::hint(format!(
                "{HINT}Create one with: wt switch --create <branch>{HINT:#}"
            ))?;
            return Ok(());
        }

        let metrics = SummaryMetrics::from_items(items);

        use anstyle::Style;
        let dim = Style::new().dimmed();

        let summary = metrics
            .summary_parts(include_branches, self.hidden_nonempty_count)
            .join(", ");

        crate::output::raw_terminal("")?;
        crate::output::raw_terminal(format!("{INFO_EMOJI} {dim}Showing {summary}{dim:#}"))?;
        Ok(())
    }
}
